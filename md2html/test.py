#!/usr/bin/env python3
"""
Test suite for md2html
Run with: python -m md2html.test
Generated by Claude Opus 4.1
"""

import json
import subprocess
import sys
from pathlib import Path
from typing import Dict, List, Tuple

# Colors for terminal output
class Colors:
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    RESET = '\033[0m'
    BOLD = '\033[1m'

def run_md2html(args: List[str]) -> Tuple[bool, str, str]:
    """Run md2html with given arguments and return success, stdout, stderr"""
    cmd = [sys.executable, '-m', 'md2html.md2html'] + args
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.returncode == 0, result.stdout, result.stderr
    except Exception as e:
        return False, "", str(e)

def parse_dag_output(output: str) -> Dict:
    """Parse the JSON DAG output"""
    try:
        return json.loads(output)
    except json.JSONDecodeError:
        return None

def check_for_duplicates(nodes: List[Dict]) -> List[str]:
    """Check for duplicate input or output files"""
    issues = []
    inputs = [node['input'] for node in nodes]
    outputs = [node['output'] for node in nodes if node['output']]
    
    # Check duplicate inputs
    seen_inputs = set()
    for inp in inputs:
        if inp in seen_inputs:
            issues.append(f"Duplicate input: {inp}")
        seen_inputs.add(inp)
    
    # Check duplicate outputs
    seen_outputs = set()
    for out in outputs:
        if out in seen_outputs:
            issues.append(f"Duplicate output: {out}")
        seen_outputs.add(out)
    
    return issues

def check_for_loops(nodes: List[Dict]) -> List[str]:
    """Check for potential infinite loops (input == output)"""
    issues = []
    for node in nodes:
        if node['output']:
            # Resolve paths for comparison
            inp_path = Path(node['input']).resolve()
            out_path = Path(node['output']).resolve()
            if inp_path == out_path:
                issues.append(f"Loop detected: {node['input']} -> {node['output']}")
    return issues

def check_ignore_patterns(nodes: List[Dict]) -> List[str]:
    """Check if files that should be ignored are in the DAG"""
    issues = []
    for node in nodes:
        filename = Path(node['input']).name
        if filename.startswith('_') or filename.startswith('.'):
            issues.append(f"Should ignore: {filename}")
    return issues

def setup_test_files(test_dir: Path):
    """Create test directory structure and files"""
    # Clean existing test directories (but leave results for inspection)
    for subdir in ['simple', 'recursive', 'mixed', 'ignore', 'edge']:
        (test_dir / subdir).mkdir(parents=True, exist_ok=True)
    
    # Simple test files
    (test_dir / 'simple' / 'file1.md').write_text('# File 1\nContent 1')
    (test_dir / 'simple' / 'file2.md').write_text('# File 2\nContent 2')
    (test_dir / 'simple' / 'style.css').write_text('body { margin: 0; }')
    
    # Recursive directory structure
    (test_dir / 'recursive' / 'root.md').write_text('# Root')
    (test_dir / 'recursive' / 'subdir1').mkdir(exist_ok=True)
    (test_dir / 'recursive' / 'subdir1' / 'sub1.md').write_text('# Sub 1')
    (test_dir / 'recursive' / 'subdir1' / 'subdir2').mkdir(exist_ok=True)
    (test_dir / 'recursive' / 'subdir1' / 'subdir2' / 'deep.md').write_text('# Deep')
    (test_dir / 'recursive' / 'style.css').write_text('/* CSS */')
    (test_dir / 'recursive' / 'subdir1' / 'script.js').write_text('// JS')
    
    # Mixed content
    (test_dir / 'mixed' / 'index.md').write_text('# Index')
    (test_dir / 'mixed' / 'about.md').write_text('# About')
    (test_dir / 'mixed' / 'existing.html').write_text('<html></html>')
    (test_dir / 'mixed' / 'styles.css').write_text('/* Styles */')
    
    # Files to ignore
    (test_dir / 'ignore' / '.hidden.md').write_text('# Hidden')
    (test_dir / 'ignore' / '_private.md').write_text('# Private')
    (test_dir / 'ignore' / 'normal.md').write_text('# Normal')
    (test_dir / 'ignore' / '.git').mkdir(exist_ok=True)
    (test_dir / 'ignore' / '.git' / 'config').write_text('git config')
    (test_dir / 'ignore' / '_templates').mkdir(exist_ok=True)
    (test_dir / 'ignore' / '_templates' / 'template.md').write_text('# Template')
    
    # Edge cases
    (test_dir / 'edge' / 'file.md').write_text('# Edge case')

def run_test(name: str, args: List[str], checks: List[str] = None) -> bool:
    """Run a single test and report results"""
    print(f"\n{Colors.BOLD}Test: {name}{Colors.RESET}")
    print(f"  Command: md2html {' '.join(args)}")
    
    success, stdout, stderr = run_md2html(args)
    
    if not success:
        print(f"  {Colors.RED}✗ Command failed{Colors.RESET}")
        if stderr:
            print(f"  Error: {stderr[:200]}")
        return False
    
    dag = parse_dag_output(stdout)
    if not dag:
        print(f"  {Colors.RED}✗ Invalid JSON output{Colors.RESET}")
        return False
    
    nodes = dag.get('nodes', [])
    print(f"  Nodes: {len(nodes)} ({sum(1 for n in nodes if n['type'] == 'markdown')} markdown, "
          f"{sum(1 for n in nodes if n['type'] == 'copy')} copy)")
    
    all_issues = []
    
    if not checks or 'duplicates' in checks:
        issues = check_for_duplicates(nodes)
        if issues:
            all_issues.extend(issues)
    
    if not checks or 'loops' in checks:
        issues = check_for_loops(nodes)
        if issues:
            all_issues.extend(issues)
    
    if not checks or 'ignore' in checks:
        issues = check_ignore_patterns(nodes)
        if issues:
            all_issues.extend(issues)
    
    if all_issues:
        print(f"  {Colors.YELLOW}⚠ Issues found:{Colors.RESET}")
        for issue in all_issues:
            print(f"    - {issue}")
        return False
    
    print(f"  {Colors.GREEN}✓ Passed{Colors.RESET}")
    return True

def main():
    """Run all tests"""
    print(f"{Colors.BOLD}{Colors.BLUE}=== md2html Test Suite ==={Colors.RESET}")
    
    # Get test directory
    project_root = Path(__file__).parent.parent
    test_dir = project_root / 'tests'
    test_dir.mkdir(exist_ok=True)
    
    print(f"Setting up test files in {test_dir}")
    setup_test_files(test_dir)
    
    # Track results
    passed = 0
    failed = 0
    
    # Test 1: Single file
    if run_test(
        "Single file",
        [str(test_dir / 'simple' / 'file1.md'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 2: Single file with output
    if run_test(
        "Single file with output",
        [str(test_dir / 'simple' / 'file1.md'), '-o', str(test_dir / 'output.html'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 3: Multiple files
    if run_test(
        "Multiple files",
        [str(test_dir / 'simple' / 'file1.md'), str(test_dir / 'simple' / 'file2.md'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 4: Directory recursive
    if run_test(
        "Recursive directory",
        ['-r', str(test_dir / 'recursive'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 5: Directory with output
    if run_test(
        "Recursive with output directory",
        ['-r', str(test_dir / 'recursive'), '-o', str(test_dir / 'output'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 6: Multiple directories
    if run_test(
        "Multiple source directories",
        ['-r', str(test_dir / 'simple'), str(test_dir / 'mixed'), 
         '-o', str(test_dir / 'output'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 7: Ignore patterns
    if run_test(
        "Ignore hidden/private files",
        ['-r', str(test_dir / 'ignore'), '--dry-run'],
        ['duplicates', 'loops', 'ignore']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 8: Same input/output directory (edge case)
    if run_test(
        "Output same as input directory",
        ['-r', str(test_dir / 'mixed'), '-o', str(test_dir / 'mixed'), '--dry-run'],
        ['duplicates', 'loops']
    ):
        passed += 1
    else:
        failed += 1
    
    # Test 9: Error handling - non-existent file
    print(f"\n{Colors.BOLD}Test: Non-existent file (should fail){Colors.RESET}")
    success, stdout, stderr = run_md2html([str(test_dir / 'nonexistent.md'), '--dry-run'])
    if not success and 'does not exist' in stderr:
        print(f"  {Colors.GREEN}✓ Correctly failed with error message{Colors.RESET}")
        passed += 1
    else:
        print(f"  {Colors.RED}✗ Should have failed{Colors.RESET}")
        failed += 1
    
    # Test 10: Error handling - directory without recursive
    print(f"\n{Colors.BOLD}Test: Directory without -r flag (should fail){Colors.RESET}")
    success, stdout, stderr = run_md2html([str(test_dir / 'recursive'), '--dry-run'])
    if not success and 'recursive' in stderr.lower():
        print(f"  {Colors.GREEN}✓ Correctly failed with error message{Colors.RESET}")
        passed += 1
    else:
        print(f"  {Colors.RED}✗ Should have failed{Colors.RESET}")
        failed += 1
    
    # Summary
    print(f"\n{Colors.BOLD}{'='*50}{Colors.RESET}")
    print(f"{Colors.BOLD}Test Results:{Colors.RESET}")
    print(f"  {Colors.GREEN}Passed: {passed}{Colors.RESET}")
    if failed > 0:
        print(f"  {Colors.RED}Failed: {failed}{Colors.RESET}")
    
    total = passed + failed
    percentage = (passed / total * 100) if total > 0 else 0
    
    if failed == 0:
        print(f"\n{Colors.GREEN}{Colors.BOLD}✓ All tests passed! ({passed}/{total}){Colors.RESET}")
    else:
        print(f"\n{Colors.YELLOW}{Colors.BOLD}⚠ {failed} tests failed ({passed}/{total} = {percentage:.1f}%){Colors.RESET}")
    
    print(f"\nTest files preserved in: {test_dir}")
    print("You can inspect the generated test structure and re-run individual tests manually.")
    
    return 0 if failed == 0 else 1

if __name__ == "__main__":
    sys.exit(main())